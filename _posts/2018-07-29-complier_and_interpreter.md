---
layout:     post
title:      "Compiler and Interpreter "
subtitle:   ""
date:       2018-08-20 22:26:00
author:     "Dawei"
header-img: img/planet_earth_4k.jpg
tags:
    - programming language
---
<br>???????????????????????????????????????????????????compiler?interpreter???????????????????????????????????????????????????????????<br/>
>A one-sentence sermon: Interpreter versus compiler is a feature of a particular programming-language implementation, not a feature of the programming language. One of the more annoying and widespread misconceptions in computer science is that there are "compiled languages" such as C and "interpreted languages" such as Racket. This is nonsense: I can write an interpreter for C or a compiler for Racket. (In fact, DrRacket takes a hybrid approach not unlike Java.) There is a long history of C being implemented with compilers and functional languages being implemented with interpreters, but compilers for functional languages have been around for decades. SML/NJ, for example, compiles each module/binding to binary code.

<br>?????????????????compiler language?interpreter language???nonsense??????compile??interprer?????????????????????????????compiler?interprer????????python?Cpython??????????python??????????????java?????????Cpython???C??????????????????????CPython?????????????????<br/>
```python
import dis

def love(girl):
    print("I love"+girl)

print(dis.dis(love))

result:
  5           0 LOAD_GLOBAL              0 (print)
              2 LOAD_CONST               1 ('I love')
              4 LOAD_FAST                0 (girl)
              6 BINARY_ADD
              8 CALL_FUNCTION            1
             10 POP_TOP
             12 LOAD_CONST               0 (None)
             14 RETURN_VALUE
None
```
>There are basically two approaches to this rest-of-the-implementation for implementing some programming language B. First, we could write an interpreter in another language A that takes programs in B and produces answers. Calling such a program in A an "evaluator for B" or an "executor for B" probably makes more sense, but "interpreter for B" has been standard terminology for decades. Second, we could write a compiler in another language A that takes programs in B and produces equivalent programs in some other language C (not the language C necessarily) and then uses some pre-existing implementation for C. For compilation, we call B the source language and C the target language. A better term than "compiler" would be "translator" but again the term compiler is ubiquitous. For either the interpreter approach or the compiler approach, we call A, the language in which we are writing the implementation of B, the metalanguage. 

<br>???PL??????????????compile?interpre????compiler????translater????C???A?????B?????C??????translator?????A???source language?B???target language???????????????Java?python??????????????????python???C???interpreter????executor??evaluator??????????A???????????B?????????????????[here](https://github.com/lionsterben/Coursera/blob/master/uw_programming_languages/hw5.rkt)?<br/>
<br>?StackOverflow????????????????????????????????????????????????????????compiler??????????????????????????????????????interpreter?<br/>